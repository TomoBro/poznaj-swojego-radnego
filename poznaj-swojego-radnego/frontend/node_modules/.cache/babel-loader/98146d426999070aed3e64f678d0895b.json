{"ast":null,"code":"import PostgrestTransformBuilder from './PostgrestTransformBuilder';\nexport default class PostgrestFilterBuilder extends PostgrestTransformBuilder {\n  constructor() {\n    super(...arguments);\n    /** @deprecated Use `contains()` instead. */\n    this.cs = this.contains;\n    /** @deprecated Use `containedBy()` instead. */\n    this.cd = this.containedBy;\n    /** @deprecated Use `rangeLt()` instead. */\n    this.sl = this.rangeLt;\n    /** @deprecated Use `rangeGt()` instead. */\n    this.sr = this.rangeGt;\n    /** @deprecated Use `rangeGte()` instead. */\n    this.nxl = this.rangeGte;\n    /** @deprecated Use `rangeLte()` instead. */\n    this.nxr = this.rangeLte;\n    /** @deprecated Use `rangeAdjacent()` instead. */\n    this.adj = this.rangeAdjacent;\n    /** @deprecated Use `overlaps()` instead. */\n    this.ov = this.overlaps;\n  }\n  /**\n   * Finds all rows which doesn't satisfy the filter.\n   *\n   * @param column  The column to filter on.\n   * @param operator  The operator to filter with.\n   * @param value  The value to filter with.\n   */\n  not(column, operator, value) {\n    this.url.searchParams.append(`${column}`, `not.${operator}.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows satisfying at least one of the filters.\n   *\n   * @param filters  The filters to use, separated by commas.\n   * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n   */\n  or(filters, {\n    foreignTable\n  } = {}) {\n    const key = typeof foreignTable === 'undefined' ? 'or' : `${foreignTable}.or`;\n    this.url.searchParams.append(key, `(${filters})`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` exactly matches the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  eq(column, value) {\n    this.url.searchParams.append(`${column}`, `eq.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` doesn't match the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  neq(column, value) {\n    this.url.searchParams.append(`${column}`, `neq.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` is greater than the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  gt(column, value) {\n    this.url.searchParams.append(`${column}`, `gt.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` is greater than or\n   * equal to the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  gte(column, value) {\n    this.url.searchParams.append(`${column}`, `gte.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` is less than the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  lt(column, value) {\n    this.url.searchParams.append(`${column}`, `lt.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` is less than or equal\n   * to the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  lte(column, value) {\n    this.url.searchParams.append(`${column}`, `lte.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value in the stated `column` matches the supplied\n   * `pattern` (case sensitive).\n   *\n   * @param column  The column to filter on.\n   * @param pattern  The pattern to filter with.\n   */\n  like(column, pattern) {\n    this.url.searchParams.append(`${column}`, `like.${pattern}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value in the stated `column` matches the supplied\n   * `pattern` (case insensitive).\n   *\n   * @param column  The column to filter on.\n   * @param pattern  The pattern to filter with.\n   */\n  ilike(column, pattern) {\n    this.url.searchParams.append(`${column}`, `ilike.${pattern}`);\n    return this;\n  }\n  /**\n   * A check for exact equality (null, true, false), finds all rows whose\n   * value on the stated `column` exactly match the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  is(column, value) {\n    this.url.searchParams.append(`${column}`, `is.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` is found on the\n   * specified `values`.\n   *\n   * @param column  The column to filter on.\n   * @param values  The values to filter with.\n   */\n  in(column, values) {\n    const cleanedValues = values.map(s => {\n      // handle postgrest reserved characters\n      // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n      if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`;else return `${s}`;\n    }).join(',');\n    this.url.searchParams.append(`${column}`, `in.(${cleanedValues})`);\n    return this;\n  }\n  /**\n   * Finds all rows whose json, array, or range value on the stated `column`\n   * contains the values specified in `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  contains(column, value) {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(`${column}`, `cs.${value}`);\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(`${column}`, `cs.{${value.join(',')}}`);\n    } else {\n      // json\n      this.url.searchParams.append(`${column}`, `cs.${JSON.stringify(value)}`);\n    }\n    return this;\n  }\n  /**\n   * Finds all rows whose json, array, or range value on the stated `column` is\n   * contained by the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  containedBy(column, value) {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(`${column}`, `cd.${value}`);\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(`${column}`, `cd.{${value.join(',')}}`);\n    } else {\n      // json\n      this.url.searchParams.append(`${column}`, `cd.${JSON.stringify(value)}`);\n    }\n    return this;\n  }\n  /**\n   * Finds all rows whose range value on the stated `column` is strictly to the\n   * left of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeLt(column, range) {\n    this.url.searchParams.append(`${column}`, `sl.${range}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose range value on the stated `column` is strictly to\n   * the right of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeGt(column, range) {\n    this.url.searchParams.append(`${column}`, `sr.${range}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose range value on the stated `column` does not extend\n   * to the left of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeGte(column, range) {\n    this.url.searchParams.append(`${column}`, `nxl.${range}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose range value on the stated `column` does not extend\n   * to the right of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeLte(column, range) {\n    this.url.searchParams.append(`${column}`, `nxr.${range}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose range value on the stated `column` is adjacent to\n   * the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeAdjacent(column, range) {\n    this.url.searchParams.append(`${column}`, `adj.${range}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose array or range value on the stated `column` overlaps\n   * (has a value in common) with the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  overlaps(column, value) {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(`${column}`, `ov.${value}`);\n    } else {\n      // array\n      this.url.searchParams.append(`${column}`, `ov.{${value.join(',')}}`);\n    }\n    return this;\n  }\n  /**\n   * Finds all rows whose text or tsvector value on the stated `column` matches\n   * the tsquery in `query`.\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   * @param type  The type of tsquery conversion to use on `query`.\n   */\n  textSearch(column, query, {\n    config,\n    type = null\n  } = {}) {\n    let typePart = '';\n    if (type === 'plain') {\n      typePart = 'pl';\n    } else if (type === 'phrase') {\n      typePart = 'ph';\n    } else if (type === 'websearch') {\n      typePart = 'w';\n    }\n    const configPart = config === undefined ? '' : `(${config})`;\n    this.url.searchParams.append(`${column}`, `${typePart}fts${configPart}.${query}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * to_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` instead.\n   */\n  fts(column, query, {\n    config\n  } = {}) {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n    this.url.searchParams.append(`${column}`, `fts${configPart}.${query}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * plainto_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'plain'` instead.\n   */\n  plfts(column, query, {\n    config\n  } = {}) {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n    this.url.searchParams.append(`${column}`, `plfts${configPart}.${query}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * phraseto_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'phrase'` instead.\n   */\n  phfts(column, query, {\n    config\n  } = {}) {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n    this.url.searchParams.append(`${column}`, `phfts${configPart}.${query}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * websearch_to_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'websearch'` instead.\n   */\n  wfts(column, query, {\n    config\n  } = {}) {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n    this.url.searchParams.append(`${column}`, `wfts${configPart}.${query}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose `column` satisfies the filter.\n   *\n   * @param column  The column to filter on.\n   * @param operator  The operator to filter with.\n   * @param value  The value to filter with.\n   */\n  filter(column, operator, value) {\n    this.url.searchParams.append(`${column}`, `${operator}.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose columns match the specified `query` object.\n   *\n   * @param query  The object to filter with, with column names as keys mapped\n   *               to their filter values.\n   */\n  match(query) {\n    Object.keys(query).forEach(key => {\n      this.url.searchParams.append(`${key}`, `eq.${query[key]}`);\n    });\n    return this;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}