{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { get, post, put, remove } from './lib/fetch';\nimport { COOKIE_OPTIONS } from './lib/constants';\nimport { setCookies, getCookieString } from './lib/cookies';\nimport { expiresAt, resolveFetch } from './lib/helpers';\nexport default class GoTrueApi {\n  constructor({\n    url = '',\n    headers = {},\n    cookieOptions,\n    fetch\n  }) {\n    this.url = url;\n    this.headers = headers;\n    this.cookieOptions = Object.assign(Object.assign({}, COOKIE_OPTIONS), cookieOptions);\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n  _createRequestHeaders(jwt) {\n    const headers = Object.assign({}, this.headers);\n    headers['Authorization'] = `Bearer ${jwt}`;\n    return headers;\n  }\n  cookieName() {\n    var _a;\n    return (_a = this.cookieOptions.name) !== null && _a !== void 0 ? _a : '';\n  }\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  getUrlForProvider(provider, options) {\n    const urlParams = [`provider=${encodeURIComponent(provider)}`];\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.queryParams) {\n      const query = new URLSearchParams(options.queryParams);\n      urlParams.push(`${query}`);\n    }\n    return `${this.url}/authorize?${urlParams.join('&')}`;\n  }\n  /**\n   * Creates a new user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  signUpWithEmail(email, password, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n        if (options.redirectTo) {\n          queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const data = yield post(this.fetch, `${this.url}/signup${queryString}`, {\n          email,\n          password,\n          data: options.data,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  signInWithEmail(email, password, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '?grant_type=password';\n        if (options.redirectTo) {\n          queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          email,\n          password,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Signs up a new user using their phone number and a password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  signUpWithPhone(phone, password, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/signup`, {\n          phone,\n          password,\n          data: options.data,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their phone number and password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  signInWithPhone(phone, password, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const queryString = '?grant_type=password';\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          phone,\n          password,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an OpenID Connect user using their id_token.\n   * @param id_token The IDToken of the user.\n   * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n   * @param provider The provider of the user.\n   * @param client_id The clientID of the user.\n   * @param issuer The issuer of the user.\n   */\n  signInWithOpenIDConnect({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const queryString = '?grant_type=id_token';\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          id_token,\n          nonce,\n          client_id,\n          issuer,\n          provider\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a magic login link to an email address.\n   * @param email The email address of the user.\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  sendMagicLinkEmail(email, options = {}) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n        const data = yield post(this.fetch, `${this.url}/otp${queryString}`, {\n          email,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n   * @param phone The user's phone number WITH international prefix\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  sendMobileOTP(phone, options = {}) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/otp`, {\n          phone,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n  signOut(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield post(this.fetch, `${this.url}/logout`, {}, {\n          headers: this._createRequestHeaders(jwt),\n          noResolveJson: true\n        });\n        return {\n          error: null\n        };\n      } catch (e) {\n        return {\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * @deprecated Use `verifyOTP` instead!\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  verifyMobileOTP(phone, token, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/verify`, {\n          phone,\n          token,\n          type: 'sms',\n          redirect_to: options.redirectTo\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Send User supplied Email / Mobile OTP to be verified\n   * @param email The user's email address\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param type verification type that the otp is generated for\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  verifyOTP({\n    email,\n    phone,\n    token,\n    type = 'sms'\n  }, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/verify`, {\n          email,\n          phone,\n          token,\n          type,\n          redirect_to: options.redirectTo\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata\n   */\n  inviteUserByEmail(email, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const data = yield post(this.fetch, `${this.url}/invite${queryString}`, {\n          email,\n          data: options.data\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a reset request to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  resetPasswordForEmail(email, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const data = yield post(this.fetch, `${this.url}/recover${queryString}`, {\n          email,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  refreshAccessToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/token?grant_type=refresh_token`, {\n          refresh_token: refreshToken\n        }, {\n          headers: this.headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Set/delete the auth cookie based on the AuthChangeEvent.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   * @param req The request object.\n   * @param res The response object.\n   */\n  setAuthCookie(req, res) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST');\n      res.status(405).end('Method Not Allowed');\n    }\n    const {\n      event,\n      session\n    } = req.body;\n    if (!event) throw new Error('Auth event missing!');\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!');\n      setCookies(req, res, [{\n        key: 'access-token',\n        value: session.access_token\n      }, {\n        key: 'refresh-token',\n        value: session.refresh_token\n      }].map(token => {\n        var _a;\n        return {\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite\n        };\n      }));\n    }\n    if (event === 'SIGNED_OUT') {\n      setCookies(req, res, ['access-token', 'refresh-token'].map(key => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1\n      })));\n    }\n    res.status(200).json({});\n  }\n  /**\n   * Deletes the Auth Cookies and redirects to the\n   * @param req The request object.\n   * @param res The response object.\n   * @param options Optionally specify a `redirectTo` URL in the options.\n   */\n  deleteAuthCookie(req, res, {\n    redirectTo = '/'\n  }) {\n    setCookies(req, res, ['access-token', 'refresh-token'].map(key => ({\n      name: `${this.cookieName()}-${key}`,\n      value: '',\n      maxAge: -1\n    })));\n    return res.redirect(307, redirectTo);\n  }\n  /**\n   * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n   * @param req The request object.\n   * @param res The response object.\n   * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n   */\n  getAuthCookieString(req, res) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST');\n      res.status(405).end('Method Not Allowed');\n    }\n    const {\n      event,\n      session\n    } = req.body;\n    if (!event) throw new Error('Auth event missing!');\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!');\n      return getCookieString(req, res, [{\n        key: 'access-token',\n        value: session.access_token\n      }, {\n        key: 'refresh-token',\n        value: session.refresh_token\n      }].map(token => {\n        var _a;\n        return {\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite\n        };\n      }));\n    }\n    if (event === 'SIGNED_OUT') {\n      return getCookieString(req, res, ['access-token', 'refresh-token'].map(key => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1\n      })));\n    }\n    return res.getHeader('Set-Cookie');\n  }\n  /**\n   * Generates links to be sent via email or other.\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   * @param email The user's email.\n   * @param password User password. For signup only.\n   * @param data Optional user metadata. For signup only.\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   */\n  generateLink(type, email, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/generate_link`, {\n          type,\n          email,\n          password: options.password,\n          data: options.data,\n          redirect_to: options.redirectTo\n        }, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  // User Admin API\n  /**\n   * Creates a new user.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param attributes The data you want to create the user with.\n   */\n  createUser(attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/users`, attributes, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  listUsers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/admin/users`, {\n          headers: this.headers\n        });\n        return {\n          data: data.users,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  getUserById(uid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/admin/users/${uid}`, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get user by reading the cookie from the request.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n  getUserByCookie(req, res) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!req.cookies) {\n          throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');\n        }\n        const access_token = req.cookies[`${this.cookieName()}-access-token`];\n        const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`];\n        if (!access_token) {\n          throw new Error('No cookie found!');\n        }\n        const {\n          user,\n          error: getUserError\n        } = yield this.getUser(access_token);\n        if (getUserError) {\n          if (!refresh_token) throw new Error('No refresh_token cookie found!');\n          if (!res) throw new Error('You need to pass the res object to automatically refresh the session!');\n          const {\n            data,\n            error\n          } = yield this.refreshAccessToken(refresh_token);\n          if (error) {\n            throw error;\n          } else if (data) {\n            setCookies(req, res, [{\n              key: 'access-token',\n              value: data.access_token\n            }, {\n              key: 'refresh-token',\n              value: data.refresh_token\n            }].map(token => {\n              var _a;\n              return {\n                name: `${this.cookieName()}-${token.key}`,\n                value: token.value,\n                domain: this.cookieOptions.domain,\n                maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                path: this.cookieOptions.path,\n                sameSite: this.cookieOptions.sameSite\n              };\n            }));\n            return {\n              token: data.access_token,\n              user: data.user,\n              data: data.user,\n              error: null\n            };\n          }\n        }\n        return {\n          token: access_token,\n          user: user,\n          data: user,\n          error: null\n        };\n      } catch (e) {\n        return {\n          token: null,\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  updateUserById(uid, attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this; //\n        const data = yield put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param uid The user uid you want to remove.\n   */\n  deleteUser(uid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield remove(this.fetch, `${this.url}/admin/users/${uid}`, {}, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Gets the current user details.\n   *\n   * This method is called by the GoTrueClient `update` where\n   * the jwt is set to this.currentSession.access_token\n   * and therefore, acts like getting the currently authenticated user\n   *\n   * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n   */\n  getUser(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/user`, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates the user data.\n   * @param jwt A valid, logged-in JWT.\n   * @param attributes The data you want to update.\n   */\n  updateUser(jwt, attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield put(this.fetch, `${this.url}/user`, attributes, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module"}