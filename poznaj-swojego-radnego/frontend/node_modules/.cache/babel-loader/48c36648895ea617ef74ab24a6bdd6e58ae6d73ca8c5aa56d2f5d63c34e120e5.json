{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { get, post, put, remove } from './lib/fetch';\nimport { COOKIE_OPTIONS } from './lib/constants';\nimport { setCookies, getCookieString } from './lib/cookies';\nimport { expiresAt, resolveFetch } from './lib/helpers';\nexport default class GoTrueApi {\n  constructor({\n    url = '',\n    headers = {},\n    cookieOptions,\n    fetch\n  }) {\n    this.url = url;\n    this.headers = headers;\n    this.cookieOptions = Object.assign(Object.assign({}, COOKIE_OPTIONS), cookieOptions);\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n  _createRequestHeaders(jwt) {\n    const headers = Object.assign({}, this.headers);\n    headers['Authorization'] = `Bearer ${jwt}`;\n    return headers;\n  }\n  cookieName() {\n    var _a;\n    return (_a = this.cookieOptions.name) !== null && _a !== void 0 ? _a : '';\n  }\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  getUrlForProvider(provider, options) {\n    const urlParams = [`provider=${encodeURIComponent(provider)}`];\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.queryParams) {\n      const query = new URLSearchParams(options.queryParams);\n      urlParams.push(`${query}`);\n    }\n    return `${this.url}/authorize?${urlParams.join('&')}`;\n  }\n  /**\n   * Creates a new user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  signUpWithEmail(email, password, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n        if (options.redirectTo) {\n          queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const data = yield post(this.fetch, `${this.url}/signup${queryString}`, {\n          email,\n          password,\n          data: options.data,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  signInWithEmail(email, password, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '?grant_type=password';\n        if (options.redirectTo) {\n          queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          email,\n          password,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Signs up a new user using their phone number and a password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  signUpWithPhone(phone, password, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/signup`, {\n          phone,\n          password,\n          data: options.data,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their phone number and password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  signInWithPhone(phone, password, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const queryString = '?grant_type=password';\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          phone,\n          password,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an OpenID Connect user using their id_token.\n   * @param id_token The IDToken of the user.\n   * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n   * @param provider The provider of the user.\n   * @param client_id The clientID of the user.\n   * @param issuer The issuer of the user.\n   */\n  signInWithOpenIDConnect({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const queryString = '?grant_type=id_token';\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          id_token,\n          nonce,\n          client_id,\n          issuer,\n          provider\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a magic login link to an email address.\n   * @param email The email address of the user.\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  sendMagicLinkEmail(email, options = {}) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n        const data = yield post(this.fetch, `${this.url}/otp${queryString}`, {\n          email,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n   * @param phone The user's phone number WITH international prefix\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  sendMobileOTP(phone, options = {}) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/otp`, {\n          phone,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n  signOut(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield post(this.fetch, `${this.url}/logout`, {}, {\n          headers: this._createRequestHeaders(jwt),\n          noResolveJson: true\n        });\n        return {\n          error: null\n        };\n      } catch (e) {\n        return {\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * @deprecated Use `verifyOTP` instead!\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  verifyMobileOTP(phone, token, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/verify`, {\n          phone,\n          token,\n          type: 'sms',\n          redirect_to: options.redirectTo\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Send User supplied Email / Mobile OTP to be verified\n   * @param email The user's email address\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param type verification type that the otp is generated for\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  verifyOTP({\n    email,\n    phone,\n    token,\n    type = 'sms'\n  }, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/verify`, {\n          email,\n          phone,\n          token,\n          type,\n          redirect_to: options.redirectTo\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata\n   */\n  inviteUserByEmail(email, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const data = yield post(this.fetch, `${this.url}/invite${queryString}`, {\n          email,\n          data: options.data\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a reset request to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  resetPasswordForEmail(email, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const data = yield post(this.fetch, `${this.url}/recover${queryString}`, {\n          email,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  refreshAccessToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/token?grant_type=refresh_token`, {\n          refresh_token: refreshToken\n        }, {\n          headers: this.headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Set/delete the auth cookie based on the AuthChangeEvent.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   * @param req The request object.\n   * @param res The response object.\n   */\n  setAuthCookie(req, res) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST');\n      res.status(405).end('Method Not Allowed');\n    }\n    const {\n      event,\n      session\n    } = req.body;\n    if (!event) throw new Error('Auth event missing!');\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!');\n      setCookies(req, res, [{\n        key: 'access-token',\n        value: session.access_token\n      }, {\n        key: 'refresh-token',\n        value: session.refresh_token\n      }].map(token => {\n        var _a;\n        return {\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite\n        };\n      }));\n    }\n    if (event === 'SIGNED_OUT') {\n      setCookies(req, res, ['access-token', 'refresh-token'].map(key => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1\n      })));\n    }\n    res.status(200).json({});\n  }\n  /**\n   * Deletes the Auth Cookies and redirects to the\n   * @param req The request object.\n   * @param res The response object.\n   * @param options Optionally specify a `redirectTo` URL in the options.\n   */\n  deleteAuthCookie(req, res, {\n    redirectTo = '/'\n  }) {\n    setCookies(req, res, ['access-token', 'refresh-token'].map(key => ({\n      name: `${this.cookieName()}-${key}`,\n      value: '',\n      maxAge: -1\n    })));\n    return res.redirect(307, redirectTo);\n  }\n  /**\n   * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n   * @param req The request object.\n   * @param res The response object.\n   * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n   */\n  getAuthCookieString(req, res) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST');\n      res.status(405).end('Method Not Allowed');\n    }\n    const {\n      event,\n      session\n    } = req.body;\n    if (!event) throw new Error('Auth event missing!');\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!');\n      return getCookieString(req, res, [{\n        key: 'access-token',\n        value: session.access_token\n      }, {\n        key: 'refresh-token',\n        value: session.refresh_token\n      }].map(token => {\n        var _a;\n        return {\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite\n        };\n      }));\n    }\n    if (event === 'SIGNED_OUT') {\n      return getCookieString(req, res, ['access-token', 'refresh-token'].map(key => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1\n      })));\n    }\n    return res.getHeader('Set-Cookie');\n  }\n  /**\n   * Generates links to be sent via email or other.\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   * @param email The user's email.\n   * @param password User password. For signup only.\n   * @param data Optional user metadata. For signup only.\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   */\n  generateLink(type, email, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/generate_link`, {\n          type,\n          email,\n          password: options.password,\n          data: options.data,\n          redirect_to: options.redirectTo\n        }, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  // User Admin API\n  /**\n   * Creates a new user.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param attributes The data you want to create the user with.\n   */\n  createUser(attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/users`, attributes, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  listUsers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/admin/users`, {\n          headers: this.headers\n        });\n        return {\n          data: data.users,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  getUserById(uid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/admin/users/${uid}`, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get user by reading the cookie from the request.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n  getUserByCookie(req, res) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!req.cookies) {\n          throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');\n        }\n        const access_token = req.cookies[`${this.cookieName()}-access-token`];\n        const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`];\n        if (!access_token) {\n          throw new Error('No cookie found!');\n        }\n        const {\n          user,\n          error: getUserError\n        } = yield this.getUser(access_token);\n        if (getUserError) {\n          if (!refresh_token) throw new Error('No refresh_token cookie found!');\n          if (!res) throw new Error('You need to pass the res object to automatically refresh the session!');\n          const {\n            data,\n            error\n          } = yield this.refreshAccessToken(refresh_token);\n          if (error) {\n            throw error;\n          } else if (data) {\n            setCookies(req, res, [{\n              key: 'access-token',\n              value: data.access_token\n            }, {\n              key: 'refresh-token',\n              value: data.refresh_token\n            }].map(token => {\n              var _a;\n              return {\n                name: `${this.cookieName()}-${token.key}`,\n                value: token.value,\n                domain: this.cookieOptions.domain,\n                maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                path: this.cookieOptions.path,\n                sameSite: this.cookieOptions.sameSite\n              };\n            }));\n            return {\n              token: data.access_token,\n              user: data.user,\n              data: data.user,\n              error: null\n            };\n          }\n        }\n        return {\n          token: access_token,\n          user: user,\n          data: user,\n          error: null\n        };\n      } catch (e) {\n        return {\n          token: null,\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  updateUserById(uid, attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this; //\n        const data = yield put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param uid The user uid you want to remove.\n   */\n  deleteUser(uid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield remove(this.fetch, `${this.url}/admin/users/${uid}`, {}, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Gets the current user details.\n   *\n   * This method is called by the GoTrueClient `update` where\n   * the jwt is set to this.currentSession.access_token\n   * and therefore, acts like getting the currently authenticated user\n   *\n   * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n   */\n  getUser(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/user`, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates the user data.\n   * @param jwt A valid, logged-in JWT.\n   * @param attributes The data you want to update.\n   */\n  updateUser(jwt, attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield put(this.fetch, `${this.url}/user`, attributes, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n}","map":{"version":3,"names":["get","post","put","remove","COOKIE_OPTIONS","setCookies","getCookieString","expiresAt","resolveFetch","GoTrueApi","constructor","url","headers","cookieOptions","fetch","Object","assign","_createRequestHeaders","jwt","cookieName","_a","name","getUrlForProvider","provider","options","urlParams","encodeURIComponent","redirectTo","push","scopes","queryParams","query","URLSearchParams","join","signUpWithEmail","email","password","queryString","data","gotrue_meta_security","captcha_token","captchaToken","session","expires_in","expires_at","error","e","signInWithEmail","signUpWithPhone","phone","signInWithPhone","signInWithOpenIDConnect","id_token","nonce","client_id","issuer","sendMagicLinkEmail","shouldCreateUser","create_user","sendMobileOTP","signOut","noResolveJson","verifyMobileOTP","token","type","redirect_to","verifyOTP","inviteUserByEmail","resetPasswordForEmail","refreshAccessToken","refreshToken","refresh_token","setAuthCookie","req","res","method","setHeader","status","end","event","body","Error","key","value","access_token","map","domain","maxAge","lifetime","path","sameSite","json","deleteAuthCookie","redirect","getAuthCookieString","getHeader","generateLink","createUser","attributes","user","listUsers","users","getUserById","uid","getUserByCookie","cookies","getUserError","getUser","updateUserById","deleteUser","updateUser"],"sources":["/Users/tomek/Documents/Poznaj_swojego_radnego/poznaj-swojego-radnego/frontend/node_modules/@supabase/gotrue-js/src/GoTrueApi.ts"],"sourcesContent":["import { Fetch, get, post, put, remove } from './lib/fetch'\nimport {\n  Session,\n  Provider,\n  AdminUserAttributes,\n  UserAttributes,\n  CookieOptions,\n  User,\n  OpenIDConnectCredentials,\n  VerifyOTPParams,\n} from './lib/types'\nimport { COOKIE_OPTIONS } from './lib/constants'\nimport { setCookies, getCookieString } from './lib/cookies'\nimport { expiresAt, resolveFetch } from './lib/helpers'\n\nimport type { ApiError } from './lib/types'\nexport default class GoTrueApi {\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected cookieOptions: CookieOptions\n  protected fetch: Fetch\n\n  constructor({\n    url = '',\n    headers = {},\n    cookieOptions,\n    fetch,\n  }: {\n    url: string\n    headers?: {\n      [key: string]: string\n    }\n    cookieOptions?: CookieOptions\n    fetch?: Fetch\n  }) {\n    this.url = url\n    this.headers = headers\n    this.cookieOptions = { ...COOKIE_OPTIONS, ...cookieOptions }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n  private _createRequestHeaders(jwt: string) {\n    const headers = { ...this.headers }\n    headers['Authorization'] = `Bearer ${jwt}`\n    return headers\n  }\n\n  private cookieName() {\n    return this.cookieOptions.name ?? ''\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  getUrlForProvider(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    if (options?.queryParams) {\n      const query = new URLSearchParams(options.queryParams)\n      urlParams.push(`${query}`)\n    }\n    return `${this.url}/authorize?${urlParams.join('&')}`\n  }\n\n  /**\n   * Creates a new user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUpWithEmail(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n      data?: object\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/signup${queryString}`,\n        {\n          email,\n          password,\n          data: options.data,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an existing user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async signInWithEmail(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = '?grant_type=password'\n      if (options.redirectTo) {\n        queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { email, password, gotrue_meta_security: { captcha_token: options.captchaToken } },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Signs up a new user using their phone number and a password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async signUpWithPhone(\n    phone: string,\n    password: string,\n    options: {\n      data?: object\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/signup`,\n        {\n          phone,\n          password,\n          data: options.data,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an existing user using their phone number and password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async signInWithPhone(\n    phone: string,\n    password: string,\n    options: {\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const queryString = '?grant_type=password'\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { phone, password, gotrue_meta_security: { captcha_token: options.captchaToken } },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an OpenID Connect user using their id_token.\n   * @param id_token The IDToken of the user.\n   * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n   * @param provider The provider of the user.\n   * @param client_id The clientID of the user.\n   * @param issuer The issuer of the user.\n   */\n  async signInWithOpenIDConnect({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider,\n  }: OpenIDConnectCredentials): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const queryString = '?grant_type=id_token'\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { id_token, nonce, client_id, issuer, provider },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a magic login link to an email address.\n   * @param email The email address of the user.\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async sendMagicLinkEmail(\n    email: string,\n    options: {\n      shouldCreateUser?: boolean\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n\n      const shouldCreateUser = options.shouldCreateUser ?? true\n      const data = await post(\n        this.fetch,\n        `${this.url}/otp${queryString}`,\n        {\n          email,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n   * @param phone The user's phone number WITH international prefix\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async sendMobileOTP(\n    phone: string,\n    options: {\n      shouldCreateUser?: boolean\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const shouldCreateUser = options.shouldCreateUser ?? true\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/otp`,\n        {\n          phone,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n  async signOut(jwt: string): Promise<{ error: ApiError | null }> {\n    try {\n      await post(\n        this.fetch,\n        `${this.url}/logout`,\n        {},\n        { headers: this._createRequestHeaders(jwt), noResolveJson: true }\n      )\n      return { error: null }\n    } catch (e) {\n      return { error: e as ApiError }\n    }\n  }\n\n  /**\n   * @deprecated Use `verifyOTP` instead!\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyMobileOTP(\n    phone: string,\n    token: string,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/verify`,\n        { phone, token, type: 'sms', redirect_to: options.redirectTo },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Send User supplied Email / Mobile OTP to be verified\n   * @param email The user's email address\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param type verification type that the otp is generated for\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyOTP(\n    { email, phone, token, type = 'sms' }: VerifyOTPParams,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/verify`,\n        { email, phone, token, type, redirect_to: options.redirectTo },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata\n   */\n  async inviteUserByEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      data?: object\n    } = {}\n  ): Promise<{ data: User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/invite${queryString}`,\n        { email, data: options.data },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a reset request to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/recover${queryString}`,\n        { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  async refreshAccessToken(\n    refreshToken: string\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const data: any = await post(\n        this.fetch,\n        `${this.url}/token?grant_type=refresh_token`,\n        { refresh_token: refreshToken },\n        { headers: this.headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Set/delete the auth cookie based on the AuthChangeEvent.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   * @param req The request object.\n   * @param res The response object.\n   */\n  setAuthCookie(req: any, res: any) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST')\n      res.status(405).end('Method Not Allowed')\n    }\n    const { event, session } = req.body\n\n    if (!event) throw new Error('Auth event missing!')\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!')\n      setCookies(\n        req,\n        res,\n        [\n          { key: 'access-token', value: session.access_token },\n          { key: 'refresh-token', value: session.refresh_token },\n        ].map((token) => ({\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: this.cookieOptions.lifetime ?? 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite,\n        }))\n      )\n    }\n    if (event === 'SIGNED_OUT') {\n      setCookies(\n        req,\n        res,\n        ['access-token', 'refresh-token'].map((key) => ({\n          name: `${this.cookieName()}-${key}`,\n          value: '',\n          maxAge: -1,\n        }))\n      )\n    }\n    res.status(200).json({})\n  }\n\n  /**\n   * Deletes the Auth Cookies and redirects to the\n   * @param req The request object.\n   * @param res The response object.\n   * @param options Optionally specify a `redirectTo` URL in the options.\n   */\n  deleteAuthCookie(req: any, res: any, { redirectTo = '/' }: { redirectTo?: string }) {\n    setCookies(\n      req,\n      res,\n      ['access-token', 'refresh-token'].map((key) => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1,\n      }))\n    )\n    return res.redirect(307, redirectTo)\n  }\n\n  /**\n   * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n   * @param req The request object.\n   * @param res The response object.\n   * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n   */\n  getAuthCookieString(req: any, res: any): string[] {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST')\n      res.status(405).end('Method Not Allowed')\n    }\n    const { event, session } = req.body\n\n    if (!event) throw new Error('Auth event missing!')\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!')\n      return getCookieString(\n        req,\n        res,\n        [\n          { key: 'access-token', value: session.access_token },\n          { key: 'refresh-token', value: session.refresh_token },\n        ].map((token) => ({\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: this.cookieOptions.lifetime ?? 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite,\n        }))\n      )\n    }\n    if (event === 'SIGNED_OUT') {\n      return getCookieString(\n        req,\n        res,\n        ['access-token', 'refresh-token'].map((key) => ({\n          name: `${this.cookieName()}-${key}`,\n          value: '',\n          maxAge: -1,\n        }))\n      )\n    }\n    return res.getHeader('Set-Cookie')\n  }\n\n  /**\n   * Generates links to be sent via email or other.\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   * @param email The user's email.\n   * @param password User password. For signup only.\n   * @param data Optional user metadata. For signup only.\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   */\n  async generateLink(\n    type:\n      | 'signup'\n      | 'magiclink'\n      | 'recovery'\n      | 'invite'\n      | 'email_change_current'\n      | 'email_change_new',\n    email: string,\n    options: {\n      password?: string\n      data?: object\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const data: any = await post(\n        this.fetch,\n        `${this.url}/admin/generate_link`,\n        {\n          type,\n          email,\n          password: options.password,\n          data: options.data,\n          redirect_to: options.redirectTo,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  // User Admin API\n\n  /**\n   * Creates a new user.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param attributes The data you want to create the user with.\n   */\n  async createUser(\n    attributes: AdminUserAttributes\n  ): Promise<\n    { user: null; data: null; error: ApiError } | { user: User; data: User; error: null }\n  > {\n    try {\n      const data: any = await post(this.fetch, `${this.url}/admin/users`, attributes, {\n        headers: this.headers,\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async listUsers(): Promise<{ data: null; error: ApiError } | { data: User[]; error: null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/admin/users`, {\n        headers: this.headers,\n      })\n      return { data: data.users, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async getUserById(\n    uid: string\n  ): Promise<{ data: null; error: ApiError } | { data: User; error: null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/admin/users/${uid}`, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get user by reading the cookie from the request.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n  async getUserByCookie(\n    req: any,\n    res?: any\n  ): Promise<{\n    token: string | null\n    user: User | null\n    data: User | null\n    error: ApiError | null\n  }> {\n    try {\n      if (!req.cookies) {\n        throw new Error(\n          'Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!'\n        )\n      }\n\n      const access_token = req.cookies[`${this.cookieName()}-access-token`]\n      const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`]\n\n      if (!access_token) {\n        throw new Error('No cookie found!')\n      }\n\n      const { user, error: getUserError } = await this.getUser(access_token)\n      if (getUserError) {\n        if (!refresh_token) throw new Error('No refresh_token cookie found!')\n        if (!res)\n          throw new Error('You need to pass the res object to automatically refresh the session!')\n        const { data, error } = await this.refreshAccessToken(refresh_token)\n        if (error) {\n          throw error\n        } else if (data) {\n          setCookies(\n            req,\n            res,\n            [\n              { key: 'access-token', value: data.access_token },\n              { key: 'refresh-token', value: data.refresh_token! },\n            ].map((token) => ({\n              name: `${this.cookieName()}-${token.key}`,\n              value: token.value,\n              domain: this.cookieOptions.domain,\n              maxAge: this.cookieOptions.lifetime ?? 0,\n              path: this.cookieOptions.path,\n              sameSite: this.cookieOptions.sameSite,\n            }))\n          )\n          return { token: data.access_token, user: data.user, data: data.user, error: null }\n        }\n      }\n      return { token: access_token, user: user, data: user, error: null }\n    } catch (e) {\n      return { token: null, user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async updateUserById(\n    uid: string,\n    attributes: AdminUserAttributes\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      this //\n      const data: any = await put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n        headers: this.headers,\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param uid The user uid you want to remove.\n   */\n  async deleteUser(\n    uid: string\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await remove(\n        this.fetch,\n        `${this.url}/admin/users/${uid}`,\n        {},\n        {\n          headers: this.headers,\n        }\n      )\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Gets the current user details.\n   *\n   * This method is called by the GoTrueClient `update` where\n   * the jwt is set to this.currentSession.access_token\n   * and therefore, acts like getting the currently authenticated user\n   *\n   * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n   */\n  async getUser(\n    jwt: string\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/user`, {\n        headers: this._createRequestHeaders(jwt),\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates the user data.\n   * @param jwt A valid, logged-in JWT.\n   * @param attributes The data you want to update.\n   */\n  async updateUser(\n    jwt: string,\n    attributes: UserAttributes\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await put(this.fetch, `${this.url}/user`, attributes, {\n        headers: this._createRequestHeaders(jwt),\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}